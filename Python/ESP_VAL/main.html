<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>System Monitor</title>
    <style>
        /* –°–ë–†–û–° –ò –û–°–ù–û–í–ù–´–ï –°–¢–ò–õ–ò */
        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box; 
        }
        
        /* –ë–ï–õ–´–ô –≠–ö–†–ê–ù –í –ë–†–ê–£–ó–ï–†–ï */
        body {
            background: white !important;
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            font-family: 'Segoe UI', sans-serif;
        }
        
        /* –ö–û–ù–¢–ï–ô–ù–ï–† –î–õ–Ø –û–°–ù–û–í–ù–û–ì–û –ö–û–ù–¢–ï–ù–¢–ê (–ë–ï–õ–´–ô –≠–ö–†–ê–ù) */
        #browserContent {
            width: 100%;
            height: 100%;
            background: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #333;
            text-align: center;
            padding: 20px;
            position: relative;
            z-index: 1;
        }
        
        /* –û–¢–î–ï–õ–¨–ù–´–ô OVERLAY –î–õ–Ø ESP (–ü–û–í–ï–†–• –ò–ì–†–´) */
        #gameOverlay {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            pointer-events: none !important;
            z-index: 2147483647 !important; /* –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π z-index */
            display: none; /* –°–∫—Ä—ã—Ç –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é */
        }
        
        /* –û–¢–û–ë–†–ê–ñ–ê–ï–ú OVERLAY –¢–û–õ–¨–ö–û –ö–û–ì–î–ê –ó–ê–•–í–ê–ß–ï–ù –≠–ö–†–ê–ù */
        .overlay-visible #gameOverlay {
            display: block !important;
        }
        
        /* –°–ö–†–´–í–ê–ï–ú –ë–†–ê–£–ó–ï–†–ù–´–ô –ö–û–ù–¢–ï–ù–¢ –ü–†–ò –ó–ê–•–í–ê–¢–ï */
        .overlay-visible #browserContent {
            opacity: 0;
            pointer-events: none;
        }
        
        /* –°–¢–ò–õ–ò ESP –ö–û–ú–ü–û–ù–ï–ù–¢–û–í (–¢–û–õ–¨–ö–û –í OVERLAY) */
        #radarContainer {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
            pointer-events: auto;
            z-index: 2147483647;
        }
        
        #radar {
            width: 100%;
            height: 100%;
            background: radial-gradient(
                circle,
                rgba(10, 15, 30, 0.9) 0%,
                rgba(5, 10, 20, 0.95) 70%,
                rgba(0, 0, 0, 0.98) 100%
            );
            border: 2px solid rgba(0, 175, 255, 0.8);
            border-radius: 50%;
            position: relative;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0, 175, 255, 0.5);
            backdrop-filter: blur(5px);
        }
        
        .sweepLine {
            position: absolute;
            width: 100%;
            height: 100%;
            background: conic-gradient(
                transparent 0deg,
                transparent 180deg,
                rgba(0, 255, 100, 0.3) 181deg,
                rgba(0, 255, 100, 0.6) 270deg,
                transparent 271deg
            );
            animation: sweep 2.5s linear infinite;
            border-radius: 50%;
        }
        
        @keyframes sweep {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .radarEnemy {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #ff3333;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 
                0 0 10px #ff3333,
                0 0 20px #ff3333,
                0 0 30px #ff3333;
            z-index: 10;
            animation: enemyPulse 1.5s ease-in-out infinite;
            border: 2px solid white;
        }
        
        @keyframes enemyPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 0.9; }
            50% { transform: translate(-50%, -50%) scale(1.3); opacity: 1; }
        }
        
        /* –û–ë–í–û–î–ö–ê –í–†–ê–ì–û–í */
        .enemyOutline {
            position: absolute;
            pointer-events: none;
            z-index: 2147483646;
            box-sizing: border-box;
        }
        
        .outline-box {
            position: absolute;
            border: 3px solid #ff3333;
            border-radius: 4px;
            animation: outlinePulse 2s infinite;
            box-shadow: 
                0 0 15px #ff3333,
                inset 0 0 15px rgba(255, 255, 255, 0.2);
            background: transparent;
        }
        
        @keyframes outlinePulse {
            0%, 100% { 
                box-shadow: 
                    0 0 15px #ff3333,
                    inset 0 0 15px rgba(255, 255, 255, 0.2);
            }
            50% { 
                box-shadow: 
                    0 0 25px #ff3333,
                    inset 0 0 25px rgba(255, 255, 255, 0.3);
            }
        }
        
        /* –ö–†–ï–°–¢–ò–ö –ü–†–ò–¶–ï–õ–ê */
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 24px;
            height: 24px;
            pointer-events: none;
            z-index: 2147483646;
        }
        
        .crosshair-dot {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background: #00ff9d;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px #00ff9d;
        }
        
        /* –ü–ê–ù–ï–õ–¨ –£–ü–†–ê–í–õ–ï–ù–ò–Ø –í –ë–†–ê–£–ó–ï–†–ï */
        #controlPanel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border: 2px solid #0078d7;
            border-radius: 10px;
            padding: 20px;
            width: 350px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            z-index: 1000;
        }
        
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .panel-title {
            color: #0078d7;
            font-size: 18px;
            font-weight: bold;
        }
        
        .config-group {
            margin-bottom: 15px;
        }
        
        .config-label {
            display: block;
            color: #333;
            font-size: 14px;
            margin-bottom: 5px;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        input[type="range"] {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            background: #e0e0e0;
            border-radius: 3px;
            outline: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #0078d7;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .btn {
            background: #0078d7;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            margin: 5px;
            transition: background 0.3s;
        }
        
        .btn:hover {
            background: #005a9e;
        }
        
        .btn-success {
            background: #28a745;
        }
        
        .btn-danger {
            background: #dc3545;
        }
        
        /* –û–ö–ù–û –ö–ê–õ–ò–ë–†–û–í–ö–ò */
        #calibrationWindow {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border: 3px solid #28a745;
            border-radius: 10px;
            padding: 20px;
            z-index: 2000;
            display: none;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.3);
        }
        
        .calibration-canvas {
            width: 600px;
            height: 400px;
            border: 2px solid #333;
            cursor: crosshair;
            margin-bottom: 15px;
        }
        
        .calibration-instruction {
            color: #333;
            font-size: 14px;
            margin-bottom: 15px;
            text-align: center;
        }
        
        /* –°–¢–ê–¢–£–° –ë–ê–† –í –ë–†–ê–£–ó–ï–†–ï */
        #statusBar {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 12px;
            z-index: 1000;
        }
        
        /* –°–ö–†–´–¢–´–ï –≠–õ–ï–ú–ï–ù–¢–´ */
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <!-- –ë–ï–õ–´–ô –≠–ö–†–ê–ù –í –ë–†–ê–£–ó–ï–†–ï -->
    <div id="browserContent">
        <h1 style="color: #0078d7; margin-bottom: 20px;">üñ•Ô∏è System Performance Monitor</h1>
        <p style="color: #666; max-width: 500px; margin-bottom: 30px;">
            This utility monitors system performance and provides game optimization features.
            Start screen capture to enable overlay features.
        </p>
        
        <!-- –ü–ê–ù–ï–õ–¨ –£–ü–†–ê–í–õ–ï–ù–ò–Ø -->
        <div id="controlPanel">
            <div class="panel-header">
                <div class="panel-title">üéÆ Game Assistant</div>
            </div>
            
            <div class="config-group">
                <label class="config-label">üî¥ Enemy Color Detection:</label>
                <div class="slider-container">
                    <input type="color" id="colorPicker" value="#ff0000" style="flex: 1; height: 30px;">
                    <div id="colorPreview" style="width: 30px; height: 30px; background: #ff0000; border-radius: 5px;"></div>
                </div>
            </div>
            
            <div class="config-group">
                <label class="config-label">üéØ Detection Sensitivity: <span id="sensValue">50</span>%</label>
                <input type="range" id="sensitivity" min="1" max="100" value="50" class="slider-container">
            </div>
            
            <div class="config-group">
                <label class="config-label">üìè Outline Thickness: <span id="outlineValue">3</span>px</label>
                <input type="range" id="outlineWidth" min="1" max="10" value="3">
            </div>
            
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="btn btn-success" onclick="startCapture()">üñ•Ô∏è Start Screen Capture</button>
                <button class="btn" onclick="showCalibration()">üé® Calibrate Color</button>
                <button class="btn btn-danger" onclick="stopCapture()">‚èπÔ∏è Stop Capture</button>
            </div>
            
            <div style="margin-top: 15px; font-size: 12px; color: #666; text-align: center;">
                Hotkeys: Ctrl+Shift+S (Start/Stop) | Ctrl+Shift+C (Calibrate)
            </div>
        </div>
        
        <!-- –°–¢–ê–¢–£–° –ë–ê–† -->
        <div id="statusBar">
            ‚è≥ Ready to start screen capture
        </div>
    </div>
    
    <!-- –û–ö–ù–û –ö–ê–õ–ò–ë–†–û–í–ö–ò (–ü–û–ö–ê–ó–´–í–ê–ï–¢ –°–ö–†–ò–ù–®–û–¢) -->
    <div id="calibrationWindow">
        <h3 style="color: #28a745; margin-bottom: 10px;">üéØ Color Calibration</h3>
        <p class="calibration-instruction">Click on an enemy in the screenshot below to capture its color</p>
        
        <canvas id="calibrationCanvas" class="calibration-canvas"></canvas>
        
        <div style="display: flex; gap: 10px; justify-content: center;">
            <button class="btn btn-success" onclick="confirmCalibration()">‚úÖ Confirm Color</button>
            <button class="btn" onclick="hideCalibration()">‚ùå Cancel</button>
        </div>
    </div>
    
    <!-- OVERLAY –î–õ–Ø –ò–ì–†–´ (–í–ò–î–ï–ù –¢–û–õ–¨–ö–û –ü–û–í–ï–†–• –ò–ì–†–´) -->
    <div id="gameOverlay">
        <!-- –†–ê–î–ê–† -->
        <div id="radarContainer">
            <div id="radar">
                <div class="sweepLine"></div>
                <!-- –í—Ä–∞–≥–∏ –¥–æ–±–∞–≤–ª—è—é—Ç—Å—è —á–µ—Ä–µ–∑ JS -->
            </div>
        </div>
        
        <!-- –ö–†–ï–°–¢–ò–ö –ü–†–ò–¶–ï–õ–ê -->
        <div id="crosshair">
            <div class="crosshair-dot"></div>
        </div>
        
        <!-- –û–±–≤–æ–¥–∫–∏ –≤—Ä–∞–≥–æ–≤ –¥–æ–±–∞–≤–ª—è—é—Ç—Å—è —á–µ—Ä–µ–∑ JS -->
    </div>

    <script>
        // === –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø ===
        const CONFIG = {
            enemyColor: { r: 255, g: 0, b: 0 }, // –ö—Ä–∞—Å–Ω—ã–π –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
            colorThreshold: 40,
            sensitivity: 50,
            outlineWidth: 3,
            updateInterval: 100,
            maxEnemies: 8
        };
        
        // === –°–û–°–¢–û–Ø–ù–ò–ï –°–ò–°–¢–ï–ú–´ ===
        const STATE = {
            isCapturing: false,
            screenStream: null,
            videoElement: null,
            canvas: null,
            ctx: null,
            enemies: [],
            outlines: [],
            calibrationActive: false,
            overlayVisible: false
        };
        
        // === –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø ===
        document.addEventListener('DOMContentLoaded', () => {
            initializeSystem();
            setupEventListeners();
            setupHotkeys();
            
            console.log('System initialized. Overlay will appear on top of game when capturing.');
        });
        
        function initializeSystem() {
            // –°–æ–∑–¥–∞–µ–º —Å–∫—Ä—ã—Ç—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞
            STATE.videoElement = document.createElement('video');
            STATE.canvas = document.createElement('canvas');
            STATE.ctx = STATE.canvas.getContext('2d', { willReadFrequently: true });
            
            // –ò–∑–Ω–∞—á–∞–ª—å–Ω–æ —Å–∫—Ä—ã–≤–∞–µ–º overlay
            document.getElementById('gameOverlay').style.display = 'none';
        }
        
        function setupEventListeners() {
            // –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Ü–≤–µ—Ç–∞
            document.getElementById('colorPicker').addEventListener('input', (e) => {
                const hex = e.target.value;
                updateColorFromHex(hex);
                document.getElementById('colorPreview').style.background = hex;
            });
            
            // –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
            document.getElementById('sensitivity').addEventListener('input', (e) => {
                CONFIG.sensitivity = parseInt(e.target.value);
                document.getElementById('sensValue').textContent = CONFIG.sensitivity;
            });
            
            // –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –æ–±–≤–æ–¥–∫–∏
            document.getElementById('outlineWidth').addEventListener('input', (e) => {
                CONFIG.outlineWidth = parseInt(e.target.value);
                document.getElementById('outlineValue').textContent = CONFIG.outlineWidth;
            });
        }
        
        // === –ó–ê–•–í–ê–¢ –≠–ö–†–ê–ù–ê ===
        async function startCapture() {
            if (STATE.isCapturing) {
                stopCapture();
                return;
            }
            
            updateStatus('‚è≥ Requesting screen access...');
            
            try {
                // –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º –¥–æ—Å—Ç—É–ø –∫ —ç–∫—Ä–∞–Ω—É
                STATE.screenStream = await navigator.mediaDevices.getDisplayMedia({
                    video: {
                        displaySurface: 'window',
                        width: { ideal: 1920 },
                        height: { ideal: 1080 }
                    },
                    audio: false,
                    preferCurrentTab: false
                });
                
                // –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –≤–∏–¥–µ–æ —ç–ª–µ–º–µ–Ω—Ç
                STATE.videoElement.srcObject = STATE.screenStream;
                STATE.videoElement.autoplay = true;
                STATE.videoElement.playsInline = true;
                
                STATE.videoElement.onloadedmetadata = () => {
                    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä canvas
                    STATE.canvas.width = STATE.videoElement.videoWidth;
                    STATE.canvas.height = STATE.videoElement.videoHeight;
                    
                    // –ê–ö–¢–ò–í–ò–†–£–ï–ú OVERLAY –ù–ê–î –ò–ì–†–û–ô
                    activateOverlay();
                    
                    updateStatus(`‚úÖ Capturing: ${STATE.canvas.width}x${STATE.canvas.height}`);
                    STATE.isCapturing = true;
                    
                    // –ó–∞–ø—É—Å–∫–∞–µ–º –∞–Ω–∞–ª–∏–∑
                    startAnalysis();
                    
                    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ –∑–∞—Ö–≤–∞—Ç–∞
                    STATE.screenStream.getVideoTracks()[0].addEventListener('ended', () => {
                        stopCapture();
                        updateStatus('‚ùå Screen capture stopped');
                    });
                };
                
            } catch (error) {
                console.error('Capture error:', error);
                updateStatus(`‚ùå Error: ${error.message}`);
                
                if (error.name === 'NotAllowedError') {
                    alert('Please allow screen sharing when prompted.\n\n' +
                          '1. Refresh the page\n' +
                          '2. Click "Start Screen Capture"\n' +
                          '3. Select your game window\n' +
                          '4. Click "Share"');
                }
            }
        }
        
        function activateOverlay() {
            // –î–û–ë–ê–í–õ–Ø–ï–ú –ö–õ–ê–°–° –î–õ–Ø –ê–ö–¢–ò–í–ê–¶–ò–ò OVERLAY
            document.body.classList.add('overlay-visible');
            
            // –ë–†–ê–£–ó–ï–† –°–¢–ê–ù–û–í–ò–¢–°–Ø –ë–ï–õ–´–ú, OVERLAY –ü–û–ö–ê–ó–´–í–ê–ï–¢–°–Ø –ü–û–í–ï–†–• –ò–ì–†–´
            STATE.overlayVisible = true;
            
            console.log('Overlay activated. ESP visible on top of game.');
        }
        
        function deactivateOverlay() {
            // –£–ë–ò–†–ê–ï–ú –ö–õ–ê–°–° –î–õ–Ø –î–ï–ê–ö–¢–ò–í–ê–¶–ò–ò OVERLAY
            document.body.classList.remove('overlay-visible');
            
            // –ë–†–ê–£–ó–ï–† –í–û–ó–í–†–ê–©–ê–ï–¢–°–Ø –ö –ù–û–†–ú–ê–õ–¨–ù–û–ú–£ –í–ò–î–£
            STATE.overlayVisible = false;
            
            console.log('Overlay deactivated.');
        }
        
        function stopCapture() {
            STATE.isCapturing = false;
            
            // –î–µ–∞–∫—Ç–∏–≤–∏—Ä—É–µ–º overlay
            deactivateOverlay();
            
            // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∑–∞—Ö–≤–∞—Ç
            if (STATE.screenStream) {
                STATE.screenStream.getTracks().forEach(track => track.stop());
                STATE.screenStream = null;
            }
            
            // –û—á–∏—â–∞–µ–º –≤—Ä–∞–≥–æ–≤
            clearEnemies();
            
            updateStatus('‚è∏Ô∏è Screen capture stopped');
        }
        
        // === –ê–ù–ê–õ–ò–ó –ò –û–¢–û–ë–†–ê–ñ–ï–ù–ò–ï ===
        function startAnalysis() {
            // –ò–Ω—Ç–µ—Ä–≤–∞–ª –∞–Ω–∞–ª–∏–∑–∞
            const analysisInterval = setInterval(() => {
                if (!STATE.isCapturing) {
                    clearInterval(analysisInterval);
                    return;
                }
                
                try {
                    // –†–∏—Å—É–µ–º –∫–∞–¥—Ä –Ω–∞ canvas
                    STATE.ctx.drawImage(STATE.videoElement, 0, 0, 
                        STATE.canvas.width, STATE.canvas.height);
                    
                    // –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
                    const imageData = STATE.ctx.getImageData(
                        0, 0, STATE.canvas.width, STATE.canvas.height
                    );
                    
                    // –ò—â–µ–º –≤—Ä–∞–≥–æ–≤
                    scanForEnemies(imageData);
                    
                    // –û–±–Ω–æ–≤–ª—è–µ–º –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ
                    updateRadar();
                    updateOutlines();
                    
                } catch (error) {
                    console.warn('Analysis error:', error);
                }
                
            }, CONFIG.updateInterval);
        }
        
        function scanForEnemies(imageData) {
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;
            
            const targetColor = CONFIG.enemyColor;
            const threshold = CONFIG.colorThreshold;
            const step = Math.max(2, 20 - Math.floor(CONFIG.sensitivity / 5));
            
            const enemyPixels = [];
            
            // –ë—ã—Å—Ç—Ä–æ–µ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ
            for (let y = 0; y < height; y += step) {
                for (let x = 0; x < width; x += step) {
                    const index = (y * width + x) * 4;
                    
                    const r = data[index];
                    const g = data[index + 1];
                    const b = data[index + 2];
                    
                    const colorDiff = Math.abs(r - targetColor.r) + 
                                     Math.abs(g - targetColor.g) + 
                                     Math.abs(b - targetColor.b);
                    
                    if (colorDiff < threshold) {
                        enemyPixels.push({ x, y });
                    }
                }
            }
            
            // –ö–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏—è
            STATE.enemies = clusterPixels(enemyPixels);
            
            // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ
            if (STATE.enemies.length > CONFIG.maxEnemies) {
                STATE.enemies = STATE.enemies.slice(0, CONFIG.maxEnemies);
            }
        }
        
        function clusterPixels(pixels) {
            if (pixels.length === 0) return [];
            
            const clusters = [];
            const clusterDistance = 50;
            
            for (const pixel of pixels) {
                let added = false;
                
                for (const cluster of clusters) {
                    const center = cluster.center;
                    const dist = Math.sqrt(
                        Math.pow(pixel.x - center.x, 2) + 
                        Math.pow(pixel.y - center.y, 2)
                    );
                    
                    if (dist < clusterDistance) {
                        cluster.pixels.push(pixel);
                        cluster.center.x = cluster.pixels.reduce((s, p) => s + p.x, 0) / cluster.pixels.length;
                        cluster.center.y = cluster.pixels.reduce((s, p) => s + p.y, 0) / cluster.pixels.length;
                        added = true;
                        break;
                    }
                }
                
                if (!added) {
                    clusters.push({
                        pixels: [pixel],
                        center: { x: pixel.x, y: pixel.y }
                    });
                }
            }
            
            // –§–∏–ª—å—Ç—Ä—É–µ–º —à—É–º
            return clusters.filter(c => 
                c.pixels.length > (CONFIG.sensitivity / 10)
            ).map(c => ({
                x: Math.round(c.center.x),
                y: Math.round(c.center.y),
                width: Math.max(20, Math.sqrt(c.pixels.length) * 5),
                height: Math.max(20, Math.sqrt(c.pixels.length) * 5)
            }));
        }
        
        function updateRadar() {
            const radar = document.getElementById('radar');
            
            // –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—ã—Ö –≤—Ä–∞–≥–æ–≤
            const oldElements = radar.querySelectorAll('.radarEnemy');
            oldElements.forEach(el => el.remove());
            
            // –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã—Ö –≤—Ä–∞–≥–æ–≤
            STATE.enemies.forEach((enemy, index) => {
                // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã
                const radarX = (enemy.x / STATE.canvas.width) * 100;
                const radarY = (enemy.y / STATE.canvas.height) * 100;
                
                const boundedX = Math.max(5, Math.min(95, radarX));
                const boundedY = Math.max(5, Math.min(95, radarY));
                
                // –°–æ–∑–¥–∞–µ–º —Ç–æ—á–∫—É –≤—Ä–∞–≥–∞
                const enemyDot = document.createElement('div');
                enemyDot.className = 'radarEnemy';
                enemyDot.style.left = `${boundedX}%`;
                enemyDot.style.top = `${boundedY}%`;
                enemyDot.style.animationDelay = `${index * 0.1}s`;
                
                radar.appendChild(enemyDot);
            });
        }
        
        function updateOutlines() {
            // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ –æ–±–≤–æ–¥–∫–∏
            clearOutlines();
            
            // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–µ –æ–±–≤–æ–¥–∫–∏
            STATE.enemies.forEach((enemy, index) => {
                createOutline(enemy, index);
            });
        }
        
        function createOutline(enemy, id) {
            const outline = document.createElement('div');
            outline.className = 'enemyOutline';
            outline.id = `outline_${id}`;
            
            // –ü–æ–∑–∏—Ü–∏—è –∏ —Ä–∞–∑–º–µ—Ä
            const padding = 5;
            outline.style.left = `${enemy.x - enemy.width/2 - padding}px`;
            outline.style.top = `${enemy.y - enemy.height/2 - padding}px`;
            outline.style.width = `${enemy.width + padding*2}px`;
            outline.style.height = `${enemy.height + padding*2}px`;
            
            // –†–∞–º–∫–∞
            const box = document.createElement('div');
            box.className = 'outline-box';
            box.style.borderWidth = `${CONFIG.outlineWidth}px`;
            box.style.width = '100%';
            box.style.height = '100%';
            
            outline.appendChild(box);
            document.getElementById('gameOverlay').appendChild(outline);
            STATE.outlines.push(outline);
        }
        
        function clearOutlines() {
            STATE.outlines.forEach(outline => {
                if (outline && outline.parentNode) {
                    outline.parentNode.removeChild(outline);
                }
            });
            STATE.outlines = [];
        }
        
        function clearEnemies() {
            STATE.enemies = [];
            updateRadar();
            clearOutlines();
        }
        
        // === –ö–ê–õ–ò–ë–†–û–í–ö–ê ===
        function showCalibration() {
            if (!STATE.isCapturing) {
                alert('Start screen capture first!');
                return;
            }
            
            STATE.calibrationActive = true;
            
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –æ–∫–Ω–æ –∫–∞–ª–∏–±—Ä–æ–≤–∫–∏
            const calibrationWindow = document.getElementById('calibrationWindow');
            const canvas = document.getElementById('calibrationCanvas');
            const ctx = canvas.getContext('2d');
            
            // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä canvas
            canvas.width = 600;
            canvas.height = 400;
            
            // –†–∏—Å—É–µ–º —Ç–µ–∫—É—â–∏–π —Å–∫—Ä–∏–Ω—à–æ—Ç –∏–≥—Ä—ã
            ctx.drawImage(STATE.videoElement, 0, 0, 600, 400);
            
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –æ–∫–Ω–æ
            calibrationWindow.style.display = 'block';
            
            // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–ª–∏–∫–∞ –ø–æ canvas
            canvas.onclick = (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // –ü–æ–ª—É—á–∞–µ–º —Ü–≤–µ—Ç –ø–∏–∫—Å–µ–ª—è
                const pixel = ctx.getImageData(x, y, 1, 1).data;
                const hex = rgbToHex(pixel[0], pixel[1], pixel[2]);
                
                // –û–±–Ω–æ–≤–ª—è–µ–º —Ü–≤–µ—Ç –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö
                updateColorFromRGB(pixel[0], pixel[1], pixel[2]);
                document.getElementById('colorPicker').value = hex;
                document.getElementById('colorPreview').style.background = hex;
                
                // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –º–µ—Ç–∫—É –≤—ã–±–æ—Ä–∞
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 2;
                ctx.strokeRect(x - 10, y - 10, 20, 20);
                
                updateStatus(`üéØ Color set: RGB(${pixel[0]}, ${pixel[1]}, ${pixel[2]})`);
            };
        }
        
        function hideCalibration() {
            STATE.calibrationActive = false;
            document.getElementById('calibrationWindow').style.display = 'none';
        }
        
        function confirmCalibration() {
            hideCalibration();
            updateStatus('‚úÖ Color calibration complete');
        }
        
        // === –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò ===
        function updateColorFromHex(hex) {
            const r = parseInt(hex.substr(1,2), 16);
            const g = parseInt(hex.substr(3,2), 16);
            const b = parseInt(hex.substr(5,2), 16);
            
            CONFIG.enemyColor = { r, g, b };
        }
        
        function updateColorFromRGB(r, g, b) {
            CONFIG.enemyColor = { r, g, b };
        }
        
        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }
        
        function updateStatus(message) {
            document.getElementById('statusBar').textContent = message;
        }
        
        function setupHotkeys() {
            document.addEventListener('keydown', (e) => {
                // Ctrl+Shift+S - Start/Stop capture
                if (e.ctrlKey && e.shiftKey && e.key === 'S') {
                    e.preventDefault();
                    if (STATE.isCapturing) stopCapture();
                    else startCapture();
                }
                
                // Ctrl+Shift+C - Calibrate
                if (e.ctrlKey && e.shiftKey && e.key === 'C') {
                    e.preventDefault();
                    if (STATE.isCapturing) showCalibration();
                }
                
                // Esc - Hide calibration
                if (e.key === 'Escape' && STATE.calibrationActive) {
                    hideCalibration();
                }
            });
        }
        
        // === –û–ß–ò–°–¢–ö–ê –ü–†–ò –ó–ê–ö–†–´–¢–ò–ò ===
        window.addEventListener('beforeunload', () => {
            stopCapture();
            clearEnemies();
        });
    </script>
</body>
</html>