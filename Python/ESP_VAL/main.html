<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game Radar Pro</title>
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            background: #0a0a0a; 
            color: #0af;
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }
        
        #overlay {
            position: fixed;
            top: 10px;
            right: 10px;
            width: 320px;
            background: rgba(20, 25, 40, 0.9);
            border: 2px solid #0af;
            border-radius: 10px;
            padding: 15px;
            z-index: 999999;
            backdrop-filter: blur(10px);
        }
        
        #radar {
            width: 200px;
            height: 200px;
            margin: 10px auto;
            background: radial-gradient(circle, #0a0f1a 0%, #050810 100%);
            border: 2px solid #0af;
            border-radius: 50%;
            position: relative;
            overflow: hidden;
        }
        
        .sweep {
            position: absolute;
            width: 100%;
            height: 100%;
            background: conic-gradient(transparent 70%, rgba(10, 175, 255, 0.3) 100%);
            animation: sweep 2s linear infinite;
        }
        
        @keyframes sweep {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .enemy {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #f00;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px #f00;
        }
        
        .controls {
            margin-top: 15px;
            text-align: center;
        }
        
        button {
            background: #0af;
            color: white;
            border: none;
            padding: 8px 15px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
        }
        
        button:hover {
            background: #08f;
        }
        
        #status {
            color: #0f0;
            font-size: 12px;
            margin-top: 10px;
            text-align: center;
        }
        
        #colorPicker {
            width: 100%;
            height: 30px;
            margin: 10px 0;
            cursor: pointer;
        }
        
        .config {
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        
        label {
            display: block;
            margin: 5px 0;
            font-size: 12px;
        }
        
        input[type="range"] {
            width: 100%;
        }
    </style>
</head>
<body>
    <div id="overlay">
        <h3 style="text-align: center; margin: 0 0 10px 0;">üéÆ Game Radar Pro</h3>
        
        <div class="config">
            <label>üî¥ Enemy Color: <span id="colorValue">Red</span></label>
            <input type="color" id="colorPicker" value="#ff0000">
            
            <label>üéØ Sensitivity: <span id="sensValue">50</span>%</label>
            <input type="range" id="sensitivity" min="1" max="100" value="50">
            
            <label>üìè Detection Threshold: <span id="threshValue">30</span></label>
            <input type="range" id="threshold" min="1" max="100" value="30">
        </div>
        
        <div id="radar">
            <div class="sweep"></div>
        </div>
        
        <div id="status">‚è≥ Ready - Start screen capture</div>
        
        <div class="controls">
            <button onclick="startCapture()">üñ•Ô∏è Start Capture</button>
            <button onclick="toggleOverlay()">üëÅÔ∏è Toggle Overlay</button>
            <button onclick="calibrate()">üéØ Calibrate</button>
        </div>
    </div>

    <script>
        // === –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø ===
        const CONFIG = {
            enemyColor: { r: 255, g: 0, b: 0 }, // –ö—Ä–∞—Å–Ω—ã–π –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
            sensitivity: 50,
            threshold: 30,
            updateInterval: 100, // –º—Å
            minEnemySize: 10,    // –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä –∫–ª–∞—Å—Ç–µ—Ä–∞
            game: 'VALORANT'     // –∏–ª–∏ 'CS2', 'APEX', etc
        };
        
        // === –°–û–°–¢–û–Ø–ù–ò–ï –°–ò–°–¢–ï–ú–´ ===
        let state = {
            isCapturing: false,
            stream: null,
            video: null,
            canvas: null,
            ctx: null,
            enemies: [],
            lastUpdate: 0,
            fps: 0,
            frameCount: 0,
            lastFpsUpdate: Date.now()
        };
        
        // === –≠–õ–ï–ú–ï–ù–¢–´ DOM ===
        const radar = document.getElementById('radar');
        const status = document.getElementById('status');
        const colorPicker = document.getElementById('colorPicker');
        const sensitivity = document.getElementById('sensitivity');
        const threshold = document.getElementById('threshold');
        const colorValue = document.getElementById('colorValue');
        const sensValue = document.getElementById('sensValue');
        const threshValue = document.getElementById('threshValue');
        
        // === –ù–ê–°–¢–†–û–ô–ö–ê –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–ò ===
        colorPicker.addEventListener('input', (e) => {
            const hex = e.target.value;
            const r = parseInt(hex.substr(1,2), 16);
            const g = parseInt(hex.substr(3,2), 16);
            const b = parseInt(hex.substr(5,2), 16);
            
            CONFIG.enemyColor = { r, g, b };
            colorValue.textContent = hex;
            colorValue.style.color = hex;
        });
        
        sensitivity.addEventListener('input', (e) => {
            CONFIG.sensitivity = parseInt(e.target.value);
            sensValue.textContent = CONFIG.sensitivity;
        });
        
        threshold.addEventListener('input', (e) => {
            CONFIG.threshold = parseInt(e.target.value);
            threshValue.textContent = CONFIG.threshold;
        });
        
        // === –û–°–ù–û–í–ù–´–ï –§–£–ù–ö–¶–ò–ò ===
        
        async function startCapture() {
            if (state.isCapturing) {
                stopCapture();
                return;
            }
            
            status.textContent = '‚è≥ Requesting screen access...';
            
            try {
                // 1. –ó–ê–ü–†–ê–®–ò–í–ê–ï–ú –î–û–°–¢–£–ü –ö –≠–ö–†–ê–ù–£
                state.stream = await navigator.mediaDevices.getDisplayMedia({
                    video: {
                        displaySurface: 'window', // 'monitor' –¥–ª—è –≤—Å–µ–≥–æ —ç–∫—Ä–∞–Ω–∞
                        width: { ideal: 1920 },
                        height: { ideal: 1080 }
                    },
                    audio: false
                });
                
                // 2. –°–û–ó–î–ê–ï–ú –í–ò–î–ï–û –≠–õ–ï–ú–ï–ù–¢
                state.video = document.createElement('video');
                state.video.srcObject = state.stream;
                state.video.autoplay = true;
                state.video.playsInline = true;
                
                // 3. –°–û–ó–î–ê–ï–ú CANVAS –î–õ–Ø –ê–ù–ê–õ–ò–ó–ê
                state.canvas = document.createElement('canvas');
                state.ctx = state.canvas.getContext('2d', { willReadFrequently: true });
                
                // 4. –ñ–î–ï–ú –ó–ê–ì–†–£–ó–ö–ò –í–ò–î–ï–û
                state.video.onloadedmetadata = () => {
                    state.canvas.width = state.video.videoWidth;
                    state.canvas.height = state.video.videoHeight;
                    
                    status.textContent = '‚úÖ Capturing: ' + 
                        state.canvas.width + 'x' + state.canvas.height;
                    
                    state.isCapturing = true;
                    
                    // 5. –ó–ê–ü–£–°–ö–ê–ï–ú –ê–ù–ê–õ–ò–ó
                    startAnalysis();
                    
                    // 6. –û–ë–†–ê–ë–û–¢–ö–ê –û–°–¢–ê–ù–û–í–ö–ò –ó–ê–•–í–ê–¢–ê
                    state.stream.getVideoTracks()[0].addEventListener('ended', () => {
                        stopCapture();
                        status.textContent = '‚ùå Screen capture stopped';
                    });
                };
                
            } catch (error) {
                status.textContent = '‚ùå Error: ' + error.message;
                console.error('Capture error:', error);
                
                // –ü–†–ï–î–õ–ê–ì–ê–ï–ú –ê–õ–¨–¢–ï–†–ù–ê–¢–ò–í–£
                if (error.name === 'NotAllowedError') {
                    status.innerHTML = '‚ùå Permission denied<br>' +
                        '1. Refresh page<br>' +
                        '2. Click "Start Capture"<br>' +
                        '3. Select game window<br>' +
                        '4. Click "Share"';
                }
            }
        }
        
        function stopCapture() {
            state.isCapturing = false;
            
            if (state.stream) {
                state.stream.getTracks().forEach(track => track.stop());
                state.stream = null;
            }
            
            if (state.video) {
                state.video.srcObject = null;
                state.video = null;
            }
            
            state.enemies = [];
            updateRadar();
            status.textContent = '‚è∏Ô∏è Capture stopped';
        }
        
        function startAnalysis() {
            function analyzeFrame() {
                if (!state.isCapturing || !state.video) return;
                
                // 1. –°–ß–ò–¢–ê–ï–ú FPS
                state.frameCount++;
                const now = Date.now();
                if (now - state.lastFpsUpdate >= 1000) {
                    state.fps = state.frameCount;
                    state.frameCount = 0;
                    state.lastFpsUpdate = now;
                }
                
                // 2. –†–ò–°–£–ï–ú –ö–ê–î–† –ù–ê CANVAS
                state.ctx.drawImage(state.video, 0, 0, 
                    state.canvas.width, state.canvas.height);
                
                // 3. –ê–ù–ê–õ–ò–ó–ò–†–£–ï–ú –ò–ó–û–ë–†–ê–ñ–ï–ù–ò–ï
                const imageData = state.ctx.getImageData(
                    0, 0, state.canvas.width, state.canvas.height
                );
                
                // 4. –ò–©–ï–ú –í–†–ê–ì–û–í –ü–û –¶–í–ï–¢–£
                findEnemies(imageData);
                
                // 5. –û–ë–ù–û–í–õ–Ø–ï–ú –†–ê–î–ê–†
                updateRadar();
                
                // 6. –°–õ–ï–î–£–Æ–©–ò–ô –ö–ê–î–†
                requestAnimationFrame(analyzeFrame);
            }
            
            analyzeFrame();
        }
        
        function findEnemies(imageData) {
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;
            
            const enemyColor = CONFIG.enemyColor;
            const threshold = CONFIG.threshold;
            
            const enemyPixels = [];
            
            // –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–´–ô –ü–û–ò–°–ö (–∫–∞–∂–¥—ã–π N-–π –ø–∏–∫—Å–µ–ª—å)
            const step = Math.max(1, Math.floor(20 - CONFIG.sensitivity / 5));
            
            for (let y = 0; y < height; y += step) {
                for (let x = 0; x < width; x += step) {
                    const index = (y * width + x) * 4;
                    
                    const r = data[index];
                    const g = data[index + 1];
                    const b = data[index + 2];
                    
                    // –ü–†–û–í–ï–†–ö–ê –¶–í–ï–¢–ê –° –ü–û–†–û–ì–û–ú
                    const colorDiff = Math.abs(r - enemyColor.r) + 
                                     Math.abs(g - enemyColor.g) + 
                                     Math.abs(b - enemyColor.b);
                    
                    if (colorDiff < threshold) {
                        enemyPixels.push({ x, y });
                    }
                }
            }
            
            // –ö–õ–ê–°–¢–ï–†–ò–ó–ê–¶–ò–Ø –ü–ò–ö–°–ï–õ–ï–ô –í–û –í–†–ê–ì–û–í
            state.enemies = clusterPixels(enemyPixels);
        }
        
        function clusterPixels(pixels) {
            if (pixels.length === 0) return [];
            
            const clusters = [];
            const clusterDistance = 50; // –ú–∞–∫—Å —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –º–µ–∂–¥—É –ø–∏–∫—Å–µ–ª—è–º–∏ –≤ –∫–ª–∞—Å—Ç–µ—Ä–µ
            
            for (const pixel of pixels) {
                let added = false;
                
                for (const cluster of clusters) {
                    const center = cluster.center;
                    const dist = Math.sqrt(
                        Math.pow(pixel.x - center.x, 2) + 
                        Math.pow(pixel.y - center.y, 2)
                    );
                    
                    if (dist < clusterDistance) {
                        cluster.pixels.push(pixel);
                        // –ü–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º —Ü–µ–Ω—Ç—Ä
                        cluster.center.x = cluster.pixels.reduce((sum, p) => sum + p.x, 0) / cluster.pixels.length;
                        cluster.center.y = cluster.pixels.reduce((sum, p) => sum + p.y, 0) / cluster.pixels.length;
                        added = true;
                        break;
                    }
                }
                
                if (!added) {
                    clusters.push({
                        pixels: [pixel],
                        center: { x: pixel.x, y: pixel.y }
                    });
                }
            }
            
            // –§–ò–õ–¨–¢–†–£–ï–ú –ú–ê–õ–ï–ù–¨–ö–ò–ï –ö–õ–ê–°–¢–ï–†–´ (–®–£–ú)
            return clusters.filter(c => 
                c.pixels.length >= CONFIG.minEnemySize
            ).map(c => c.center);
        }
        
        function updateRadar() {
            // –û–ß–ò–©–ê–ï–ú –°–¢–ê–†–´–• –í–†–ê–ì–û–í
            const oldEnemies = radar.querySelectorAll('.enemy');
            oldEnemies.forEach(e => e.remove());
            
            // –î–û–ë–ê–í–õ–Ø–ï–ú –ù–û–í–´–• –í–†–ê–ì–û–í
            state.enemies.forEach(enemy => {
                // –ö–û–ù–í–ï–†–¢–ò–†–£–ï–ú –≠–ö–†–ê–ù–ù–´–ï –ö–û–û–†–î–ò–ù–ê–¢–´ –í –ö–û–û–†–î–ò–ù–ê–¢–´ –†–ê–î–ê–†–ê
                const radarX = (enemy.x / state.canvas.width) * 100;
                const radarY = (enemy.y / state.canvas.height) * 100;
                
                // –û–ì–†–ê–ù–ò–ß–ò–í–ê–ï–ú –í –ü–†–ï–î–ï–õ–ê–• –†–ê–î–ê–†–ê
                const boundedX = Math.max(5, Math.min(95, radarX));
                const boundedY = Math.max(5, Math.min(95, radarY));
                
                // –°–û–ó–î–ê–ï–ú –≠–õ–ï–ú–ï–ù–¢ –í–†–ê–ì–ê
                const enemyEl = document.createElement('div');
                enemyEl.className = 'enemy';
                enemyEl.style.left = boundedX + '%';
                enemyEl.style.top = boundedY + '%';
                enemyEl.title = `X: ${Math.round(enemy.x)}, Y: ${Math.round(enemy.y)}`;
                
                // –†–ê–ó–ú–ï–† –í –ó–ê–í–ò–°–ò–ú–û–°–¢–ò –û–¢ –ë–õ–ò–ó–û–°–¢–ò –ö –¶–ï–ù–¢–†–£
                const centerDist = Math.sqrt(
                    Math.pow(boundedX - 50, 2) + 
                    Math.pow(boundedY - 50, 2)
                );
                const size = Math.max(5, 15 - centerDist / 10);
                enemyEl.style.width = size + 'px';
                enemyEl.style.height = size + 'px';
                
                radar.appendChild(enemyEl);
            });
            
            // –û–ë–ù–û–í–õ–Ø–ï–ú –°–¢–ê–¢–£–°
            status.innerHTML = `‚úÖ ${state.enemies.length} enemies detected | FPS: ${state.fps}`;
        }
        
        function toggleOverlay() {
            const overlay = document.getElementById('overlay');
            overlay.style.display = overlay.style.display === 'none' ? 'block' : 'none';
        }
        
        function calibrate() {
            status.textContent = 'üéØ Calibration mode - Click on enemy color';
            
            if (!state.isCapturing) {
                status.textContent = '‚ùå Start capture first';
                return;
            }
            
            // –°–û–ó–î–ê–ï–ú –ö–ê–õ–ò–ë–†–û–í–û–ß–ù–û–ï –û–ö–ù–û
            const calibrator = document.createElement('div');
            calibrator.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 400px;
                height: 300px;
                background: rgba(0,0,0,0.9);
                border: 3px solid #0af;
                z-index: 1000000;
                cursor: crosshair;
            `;
            
            const canvas = document.createElement('canvas');
            canvas.width = 400;
            canvas.height = 300;
            calibrator.appendChild(canvas);
            
            const ctx = canvas.getContext('2d');
            ctx.drawImage(state.video, 0, 0, 400, 300);
            
            // –û–ë–†–ê–ë–û–¢–ö–ê –ö–õ–ò–ö–ê –î–õ–Ø –í–´–ë–û–†–ê –¶–í–ï–¢–ê
            canvas.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const pixel = ctx.getImageData(x, y, 1, 1).data;
                const hex = rgbToHex(pixel[0], pixel[1], pixel[2]);
                
                // –û–ë–ù–û–í–õ–Ø–ï–ú –¶–í–ï–¢
                CONFIG.enemyColor = { r: pixel[0], g: pixel[1], b: pixel[2] };
                colorPicker.value = hex;
                colorValue.textContent = hex;
                colorValue.style.color = hex;
                
                // –ü–û–ö–ê–ó–´–í–ê–ï–ú –í–´–ë–†–ê–ù–ù–´–ô –¶–í–ï–¢
                ctx.strokeStyle = '#0f0';
                ctx.lineWidth = 2;
                ctx.strokeRect(x - 5, y - 5, 10, 10);
                
                status.textContent = `‚úÖ Color set to RGB(${pixel[0]}, ${pixel[1]}, ${pixel[2]})`;
                
                setTimeout(() => {
                    calibrator.remove();
                    status.textContent = '‚úÖ Calibration complete';
                }, 2000);
            });
            
            // –ö–ù–û–ü–ö–ê –û–¢–ú–ï–ù–´
            const cancelBtn = document.createElement('button');
            cancelBtn.textContent = 'Cancel';
            cancelBtn.style.cssText = `
                position: absolute;
                bottom: 10px;
                right: 10px;
                padding: 5px 10px;
            `;
            cancelBtn.onclick = () => {
                calibrator.remove();
                status.textContent = 'Calibration cancelled';
            };
            calibrator.appendChild(cancelBtn);
            
            document.body.appendChild(calibrator);
        }
        
        // === –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò ===
        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }
        
        // === –ò–ù–°–¢–†–£–ö–¶–ò–Ø –ü–†–ò –ó–ê–ì–†–£–ó–ö–ï ===
        window.addEventListener('load', () => {
            setTimeout(() => {
                status.innerHTML = `
                    <div style="text-align: left; font-size: 11px;">
                        <strong>INSTRUCTIONS:</strong><br>
                        1. Set Valorant to <strong>Windowed/Borderless</strong><br>
                        2. Click <strong>Start Capture</strong><br>
                        3. Select <strong>Valorant window</strong><br>
                        4. Adjust color if needed<br>
                        5. Use <strong>Calibrate</strong> for best results
                    </div>
                `;
            }, 1000);
        });
        
        // === –ì–û–†–Ø–ß–ò–ï –ö–õ–ê–í–ò–®–ò ===
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'q') {
                toggleOverlay();
            }
            if (e.ctrlKey && e.key === 's') {
                if (state.isCapturing) stopCapture();
                else startCapture();
            }
        });
        
        console.log('Game Radar Pro loaded');
        console.log('Controls:');
        console.log('- Ctrl+Q: Toggle overlay');
        console.log('- Ctrl+S: Start/Stop capture');
    </script>
</body>
</html>